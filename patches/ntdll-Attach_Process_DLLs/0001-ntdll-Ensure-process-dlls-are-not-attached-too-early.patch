From 0cb287b9ba62ee9e353248861d4c177f7db48dcb Mon Sep 17 00:00:00 2001
From: Sebastian Lackner <sebastian@fds-team.de>
Date: Wed, 20 Jul 2016 02:21:41 +0200
Subject: ntdll: Ensure process dlls are not attached too early. (v2)

---
 dlls/ntdll/loader.c | 17 ++++++++++++++++-
 1 file changed, 16 insertions(+), 1 deletion(-)

diff --git a/dlls/ntdll/loader.c b/dlls/ntdll/loader.c
index 518a99f590..94668e8ba4 100644
--- a/dlls/ntdll/loader.c
+++ b/dlls/ntdll/loader.c
@@ -64,6 +64,7 @@ typedef DWORD (CALLBACK *DLLENTRYPROC)(H
 typedef void  (CALLBACK *LDRENUMPROC)(LDR_MODULE *, void *, BOOLEAN *);
 
 static BOOL imports_fixup_done = FALSE;  /* set once the imports have been fixed up, before attaching them */
+static BOOL process_attaching = TRUE;   /* set on process attach to avoid calling callbacks too early */
 static BOOL process_detaching = FALSE;  /* set on process detach to avoid deadlocks with thread detach */
 static int free_lib_count;   /* recursion depth of LdrUnloadDll calls */
 
@@ -459,6 +460,19 @@ static FARPROC find_forwarded_export( HM
                     current_modref->deps = deps;
                 }
             }
+            if (process_attaching)
+            {
+                WINE_MODREF **deps, *prev = get_modref( module );
+                if (!prev->deps)
+                    deps = RtlAllocateHeap( GetProcessHeap(), 0, sizeof(*deps) );
+                else
+                    deps = RtlReAllocateHeap( GetProcessHeap(), 0, prev->deps, (prev->nDeps + 1) * sizeof(*deps) );
+                if (deps)
+                {
+                    prev->deps = deps;
+                    prev->deps[prev->nDeps++] = wm;
+                }
+            }
             else if (process_attach( wm, NULL ) != STATUS_SUCCESS)
             {
                 LdrUnloadDll( wm->ldr.BaseAddress );
@@ -2995,6 +3009,7 @@ NTSTATUS attach_dlls( CONTEXT *context )
     WINE_MODREF *wm;
     LPCWSTR load_path = NtCurrentTeb()->Peb->ProcessParameters->DllPath.Buffer;
 
+    process_attaching = FALSE;
     pthread_sigmask( SIG_UNBLOCK, &server_block_set, NULL );
 
     if (process_detaching) return STATUS_SUCCESS;
-- 
2.12.2

